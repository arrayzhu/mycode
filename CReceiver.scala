import java.io.{BufferedReader, InputStream, InputStreamReader}
import org.apache.log4j.{Level, Logger}
import java.net.Socket
import org.apache.spark.{Logging, SparkConf}
import org.apache.spark.streaming.{Seconds, StreamingContext}
import org.apache.spark.streaming.receiver.Receiver
import org.apache.spark.streaming._
import org.apache.spark.storage.StorageLevel

/**
  * Custom Receiver that receives data over a socket. Received bytes is interpreted as
  * text and \n delimited lines are considered as records. They are then counted and printed
  * To run this on your local machine, you need to first run a Netcat server
  * $ nc -lk 8610/8611/8612
  * and then run the CReceiver
  * $ bin/spark-submit --master spark://192.168.1.50:7077 --conf spark.streaming.concurrentJobs=100
  * spark.streaming.blockInterval=10000 /home/hadoop/sparkjar/CReceiver.jar
**/

object CReceiver {
   def main(args:Array[String]){
     if(args.length>2){
     System.err.println("Usage: CReceiver <hostname> <port>")
     System.exit(1)
     }

     //Shield unnecessary log explicitly on the terminal
     Logger.getLogger("org.apache.spark").setLevel(Level.WARN)
     Logger.getLogger("org.eclipse.jetty.server").setLevel(Level.OFF)

     //Create three streaming contexts with a 100 seconds batch size
     val sparkConf = new SparkConf().setAppName("CReceiver")
     val ssc = new StreamingContext(sparkConf,Seconds(100))

     //Create three input streams with the creceiver on target ip:port and count the
     //words in input stream of \n delimited text (eg. generated by 'nc')
     val inStream1 = ssc.receiverStream(new CReceiver("192.168.1.50",8610))
     val inStream2 = ssc.receiverStream(new CReceiver("192.168.1.50",8611))
     val inStream3 = ssc.receiverStream(new CReceiver("192.168.1.50",8612))

     //There are some transformations and actions
     val union1 = inStream1.union(inStream2)
     val union2 = inStream2.union(inStream3)
     val union3 = inStream1.union(inStream3)
     union1.cache()
     union2.cache()
     union3.cache()

     val outStream1 = union1.flatMap(_.split(" ")).map(x => (x,1)).reduceByKey(_+_)
     val outStream2 = union2.flatMap(_.split(" ")).map(x => (x,1)).reduceByKey(_+_)
     val outStream3 = union3.flatMap(_.split(" ")).map(x => (x,1)).reduceByKey(_+_)
     outStream1.foreachRDD(rdd => {while(!rdd.isEmpty()) rdd.cache()})
     outStream2.foreachRDD(rdd => {while(!rdd.isEmpty()) rdd.cache()})
     outStream3.foreachRDD(rdd => {while(!rdd.isEmpty()) rdd.cache()})

     ssc.start()
     ssc.awaitTermination()
   }
}

class CReceiver(host:String,port:Int)
  extends Receiver[String](StorageLevel.MEMORY_ONLY_2) with Logging {
  def onStart() {
    //Start the thread that receives data over a connection
    new Thread("Socket Receiver") {
      override def run() {
        receive()
      }
    }.start()
  }

  def onStop() {
    //There is nothing much to do as the thread calling receive()
    //is designed to stop by itself isStopped() returns false
  }

  /** Create a socket connection and receive data until receiver is
    stopped */

  private def receive() {
    var socket: Socket = null
    var userInput: String = null
    try {
      logInfo("Connecting to" + host + ":" + port)
      socket = new Socket(host, port)
      logInfo("Connected to" + host + ":" + port)
      val reader = new BufferedReader(new InputStreamReader(socket.getInputStream(), "UTF-8"))
      userInput = reader.readLine()
      while (!isStopped && userInput != null) {
        store(userInput)
        userInput = reader.readLine()
      }
      reader.close()
      socket.close()
      logInfo("Stopped receiving")
      restart("Trying to connect again")
    } catch {
      case e: java.net.ConnectException =>
        restart("Error connecting to" + host + ":" + port, e)
      case t: Throwable =>
        restart("Error receiving data",t)
    }
  }
}

